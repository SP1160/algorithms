// ===== АЛГОРИТМ ПРИМА - ПОШАГОВОЕ ОБЪЯСНЕНИЕ =====
// Цель: найти минимальное остовное дерево (МОД) - подграф, который:
// 1) Соединяет все вершины
// 2) Не содержит циклов
// 3) Имеет минимальную сумму весов рёбер

const prim = (vertices, edges) => {
  // ШАГ 1: Инициализация переменных
  const n = vertices.length; // Количество вершин (в нашем случае 5: A, B, C, D, E)
  const mst = []; // Массив для хранения рёбер минимального остовного дерева
  const visited = {}; // Объект для отслеживания посещённых вершин

  // ШАГ 2: Помечаем все вершины как непосещённые
  for (let i = 0; i < n; i++) {
    visited[vertices[i]] = false; // Изначально все вершины непосещены
  }

  // ШАГ 3: Выбираем стартовую вершину (первую из списка)
  visited[vertices[0]] = true; // Помечаем первую вершину как посещённую

  // ШАГ 4: Основной цикл алгоритма
  // Нужно добавить n-1 рёбер для соединения всех вершин
  for (let edgeCount = 0; edgeCount < n - 1; edgeCount++) {
    // ШАГ 4.1: Инициализируем поиск минимального ребра
    let minWeight = Infinity; // Минимальный вес (изначально бесконечность)
    let minEdge = null; // Минимальное ребро (изначально пустое)

    // ШАГ 4.2: Перебираем все рёбра в поисках минимального
    for (let i = 0; i < edges.length; i++) {
      const [from, to, weight] = edges[i]; // Разбираем ребро на составляющие

      // ШАГ 4.3: Проверяем статус вершин данного ребра
      const fromVisited = visited[from]; // Посещена ли первая вершина?
      const toVisited = visited[to]; // Посещена ли вторая вершина?

      // ШАГ 4.4: Проверяем условие "одна посещена, другая нет"
      // Это ключевое условие алгоритма Прима!
      if ((fromVisited && !toVisited) || (!fromVisited && toVisited)) {
        // ШАГ 4.5: Сравниваем с текущим минимумом
        if (weight < minWeight) {
          minWeight = weight; // Обновляем минимальный вес
          minEdge = [from, to, weight]; // Сохраняем минимальное ребро
        }
      }
    }

    // ШАГ 4.6: Добавляем найденное минимальное ребро в МОД
    if (minEdge) {
      mst.push(minEdge); // Добавляем ребро в остовное дерево

      // ШАГ 4.7: Обновляем статус посещённости
      // Помечаем новую вершину как посещённую
      if (visited[minEdge[0]]) {
        // Если первая вершина уже посещена, помечаем вторую
        visited[minEdge[1]] = true;
      } else {
        // Если вторая вершина уже посещена, помечаем первую
        visited[minEdge[0]] = true;
      }
    } else {
      break;
    }
  }

  return mst;
};

const vertices = ["A", "B", "C", "D", "E"];
const edges = [
  ["A", "B", 4],
  ["A", "C", 3],
  ["B", "C", 1],
  ["B", "D", 2],
  ["C", "D", 4],
  ["C", "E", 5],
  ["D", "E", 1],
];

console.log(prim(vertices, edges));
