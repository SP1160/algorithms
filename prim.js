// Алгоритм Прима

const prim = (graph) => {
  // получаем массив всех вершин графа — ключи объекта graph.
  const vertices = Object.keys(graph);

  // создаём объект visited, который используем как множество для пометки посещённых вершин.
  const visited = {};

  // результирующий объект, в котором будем собирать минимальное остовное дерево
  const mst = {};

  // суммарный вес всех добавленных в MST рёбер.
  let totalWeight = 0;

  // если граф пустой (нет вершин)
  if (vertices.length === 0) {
    // возвращаем пустой MST и нулевой общий вес.
    return { result: mst, totalWeight };
  }

  // Инициализируем в mst для каждой вершины пустой объект соседей,
  // чтобы в результате каждый ключ-вершина существовал.
  vertices.forEach((v) => {
    mst[v] = {};
  });

  // выбираем стартовую вершину — первую из массива vertices (порядок не важен).
  const startVertex = vertices[0];
  // помечаем стартовую вершину как посещённую — начинаем построение от неё.
  visited[startVertex] = true;

  // Основной цикл: расширяем множество посещённых вершин, пока не покроем все вершины графа.
  // сравниваем количество посещённых вершин и всех вершин
  while (Object.keys(visited).length < vertices.length) {
    // текущий минимум веса на итерации — начинаем с +∞, чтобы любое реальное ребро было меньше.
    let minWeight = Infinity;
    // переменная для хранения информации о найденном минимальном ребре: { from, to, weight }.
    let minEdge = null;

    // Перебираем все вершины, которые уже посещены — ищем среди их инцидентных рёбер минимальное,
    // которое ведёт в ещё непосещённую вершину.
    for (const u in visited) {
      // получаем объект-соседей для вершины u из исходного графа (например { "v": 4, "w": 7 })
      const neighbors = graph[u];
      // перебираем всех соседей вершины u
      for (const v in neighbors) {
        // рассматриваем только ребра, которые ведут в непосещённую вершину (u -> v)
        if (!visited[v]) {
          // извлекаем вес ребра (u,v) из объекта соседей
          const weight = neighbors[v];
          // если вес этого ребра меньше текущего минимума
          if (weight < minWeight) {
            // обновляем текущий минимум
            minWeight = weight;
            // запоминаем ребро: откуда, куда и вес
            minEdge = { from: u, to: v, weight };
          }
        }
      }
    }

    // Для связного графа minEdge обязательно будет найден на каждой итерации (поскольку всегда есть ребро из visited -> not visited),
    // но оставляем проверку на случай некорректного входных данных.
    if (!minEdge) {
      // если не нашли подходящего ребра (теоретически — это означает несвязный граф)
      // прерываем цикл, возвращаем то, что успели построить (защита от неверного входа)
      break;
    }

    // Добавляем найденное минимальное ребро в итоговую структуру mst.
    // Так как граф неориентированный, мы сохраняем ребро в обе стороны для удобства чтения и совместимости со входным форматом.
    // записываем ребро from -> to с соответствующим весом
    mst[minEdge.from][minEdge.to] = minEdge.weight;
    // записываем обратную запись to -> from (симметрично)
    mst[minEdge.to][minEdge.from] = minEdge.weight;

    // помечаем вершину `to` как посещённую — она теперь входит в остов
    visited[minEdge.to] = true;
    // увеличиваем суммарный вес MST на вес добавленного ребра
    totalWeight += minEdge.weight;
  }

  return { result: mst, totalWeight };
};

const graph = {
  A: { B: 4, C: 3 },
  B: { A: 4, C: 1, D: 2 },
  C: { A: 3, B: 1, D: 4, E: 5 },
  D: { B: 2, C: 4, E: 1 },
  E: { C: 5, D: 1 },
};

console.log(prim(graph));
