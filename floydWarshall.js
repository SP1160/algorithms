// Алгоритм Флойда-Уоршелла для поиска кратчайших путей между всеми парами вершин

function floydWarshall(graph) {
  // Получаем все уникальные вершины из графа
  const vertices = Object.keys(graph);
  const n = vertices.length;

  // Создаем матрицу смежности из объектного представления
  const adjMatrix = [];
  for (let i = 0; i < n; i++) {
    adjMatrix[i] = [];
    for (let j = 0; j < n; j++) {
      if (i === j) {
        adjMatrix[i][j] = 0; // расстояние от вершины до себя = 0
      } else if (graph[vertices[i]][vertices[j]] !== undefined) {
        adjMatrix[i][j] = graph[vertices[i]][vertices[j]]; // прямое соединение
      } else {
        adjMatrix[i][j] = Infinity; // нет прямого соединения
      }
    }
  }

  // ПЕРЕМЕННАЯ n - количество вершин в графе
  // Получаем из длины первой строки матрицы смежности
  // const n = adjMatrix.length; // уже определено выше

  // МАТРИЦА dist - матрица кратчайших расстояний
  // Изначально копируем исходную матрицу adjMatrix
  const dist = adjMatrix.map((row) => [...row]);
  // После этого: dist[i][j] = прямому расстоянию от i к j

  // ОСНОВНОЙ АЛГОРИТМ - ТРИ ВЛОЖЕННЫХ ЦИКЛА
  // ========================================================================
  // ВНЕШНИЙ ЦИКЛ: k - промежуточная вершина
  // На каждой итерации мы рассматриваем вершину k как возможную
  // промежуточную точку для улучшения путей между другими вершинами
  for (let k = 0; k < n; k++) {
    // СРЕДНИЙ ЦИКЛ: i - начальная вершина пути
    for (let i = 0; i < n; i++) {
      // ВНУТРЕННИЙ ЦИКЛ: j - конечная вершина пути
      for (let j = 0; j < n; j++) {
        // КЛЮЧЕВАЯ ПРОВЕРКА алгоритма:
        // "Короче ли путь от i к j через вершину k?"

        // dist[i][k] - кратчайшее расстояние от i до k (уже вычислено)
        // dist[k][j] - кратчайшее расстояние от k до j (уже вычислено)
        // dist[i][j] - текущее кратчайшее расстояние от i до j

        if (dist[i][k] + dist[k][j] < dist[i][j]) {
          // Если путь через k короче, обновляем расстояние
          dist[i][j] = dist[i][k] + dist[k][j];
        }
      }
    }
  }

  // Преобразуем результат обратно в объектный формат
  const result = {};
  for (let i = 0; i < n; i++) {
    result[vertices[i]] = {};
    for (let j = 0; j < n; j++) {
      result[vertices[i]][vertices[j]] = dist[i][j];
    }
  }

  return result;
}

// Пример использования
const graph = {
  a: { b: 2, c: 1 },
  b: { f: 7 },
  c: { d: 5, e: 2 },
  d: { f: 2 },
  e: { f: 1 },
  f: { g: 1 },
  g: {},
};

const shortestPaths = floydWarshall(graph);
console.log(shortestPaths);
