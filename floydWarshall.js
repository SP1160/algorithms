// Алгоритм Флойда-Уоршелла для поиска кратчайших путей между всеми парами вершин

function floydWarshall(graph) {
  // ПЕРЕМЕННАЯ n - количество вершин в графе
  // Получаем из длины первой строки матрицы смежности
  const n = graph.length;

  // МАТРИЦА dist - матрица кратчайших расстояний
  // Изначально копируем исходную матрицу graph
  const dist = graph.map((row) => [...row]);
  // После этого: dist[i][j] = прямому расстоянию от i к j

  // ОСНОВНОЙ АЛГОРИТМ - ТРИ ВЛОЖЕННЫХ ЦИКЛА
  // ========================================================================
  // ВНЕШНИЙ ЦИКЛ: k - промежуточная вершина
  // На каждой итерации мы рассматриваем вершину k как возможную
  // промежуточную точку для улучшения путей между другими вершинами
  for (let k = 0; k < n; k++) {
    // СРЕДНИЙ ЦИКЛ: i - начальная вершина пути
    for (let i = 0; i < n; i++) {
      // ВНУТРЕННИЙ ЦИКЛ: j - конечная вершина пути
      for (let j = 0; j < n; j++) {
        // КЛЮЧЕВАЯ ПРОВЕРКА алгоритма:
        // "Короче ли путь от i к j через вершину k?"

        // dist[i][k] - кратчайшее расстояние от i до k (уже вычислено)
        // dist[k][j] - кратчайшее расстояние от k до j (уже вычислено)
        // dist[i][j] - текущее кратчайшее расстояние от i до j

        if (dist[i][k] + dist[k][j] < dist[i][j]) {
          // Если путь через k короче, обновляем расстояние
          dist[i][j] = dist[i][k] + dist[k][j];
        }
      }
    }
  }

  return dist;
}

// Пример использования
const graph = [
  [0, 5, Infinity, Infinity],
  [Infinity, 0, 5, 3],
  [-3, Infinity, 0, Infinity],
  [2, Infinity, -5, 0],
];

const shortestPaths = floydWarshall(graph);
console.log(shortestPaths);
