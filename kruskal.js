/**
 * Функция для нахождения минимального остовного дерева с помощью алгоритма Крускала
 */
function kruskal(edges, vertices) {
  // ========== ШАГ 1: СОРТИРОВКА РЁБЕР ==========
  // Сортируем все рёбра по возрастанию веса
  edges.sort((a, b) => a[2] - b[2]);

  // ========== ШАГ 2: ИНИЦИАЛИЗАЦИЯ DSU (Disjoint Set Union) ==========
  // Создаём структуру данных "Система непересекающихся множеств"
  const parent = {};

  // Инициализируем массив родителей
  // parent[vertex] = vertex означает, что вершина является корнем своего множества
  for (let i = 0; i < vertices.length; i++) {
    const vertex = vertices[i];
    parent[vertex] = vertex; // Изначально каждая вершина - своё собственное множество
  }

  // ========== ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ DSU ==========

  /**
   * Функция для нахождения корня множества с применением сжатия пути
   * @param {string} u - вершина, для которой ищем корень
   * @returns {string} - корень множества
   */
  const find = (u) => {
    // Поднимаемся по дереву до тех пор, пока не найдём корень
    // Корень - это вершина, которая является родителем самой себя (parent[u] === u)
    while (parent[u] !== u) {
      // PATH COMPRESSION (Сжатие пути) - ВАЖНАЯ ОПТИМИЗАЦИЯ!
      // Вместо простого u = parent[u], мы делаем parent[u] = parent[parent[u]]
      // Это делает дерево более плоским и ускоряет будущие поиски
      parent[u] = parent[parent[u]]; // "Перепрыгиваем" через одного предка
      u = parent[u]; // Переходим к новому родителю
    }

    return u;
  };

  /**
   * Функция для объединения двух множеств
   * @param {string} u - вершина из первого множества
   * @param {string} v - вершина из второго множества
   */
  const union = (u, v) => {
    // Находим корни множеств, к которым принадлежат вершины u и v
    const rootU = find(u);
    const rootV = find(v);

    // Проверяем, не находятся ли вершины уже в одном множестве
    if (rootU !== rootV) {
      // Простое объединение: делаем rootU родителем rootV
      // Это означает, что все элементы множества rootV теперь принадлежат множеству rootU
      parent[rootV] = rootU;
    }
  };

  // ========== ШАГ 3: ОСНОВНОЙ АЛГОРИТМ ==========
  const result = {}; // Объект для хранения результата в формате смежности
  let edgeCount = 0; // Счётчик добавленных рёбер
  let totalWeight = 0; // Общий вес MST

  // Инициализируем результирующий объект пустыми объектами для каждой вершины
  for (let i = 0; i < vertices.length; i++) {
    const vertex = vertices[i];
    result[vertex] = {};
  }

  // Проходим по всем рёбрам в порядке возрастания веса
  // Используем деструктуризацию: [u, v, weight] извлекает элементы из каждого ребра
  for (const [u, v, weight] of edges) {
    // Проверяем, создаст ли добавление этого ребра цикл
    // Если вершины u и v уже находятся в одном множестве (имеют одинаковый корень),
    // то между ними уже есть путь, и добавление ребра создаст цикл
    const rootU = find(u);
    const rootV = find(v);

    if (rootU !== rootV) {
      // Вершины в разных множествах - можно безопасно добавить ребро

      // Добавляем ребро в результирующий объект смежности в обоих направлениях
      result[u][v] = weight;
      result[v][u] = weight;

      // Увеличиваем счётчики
      edgeCount++;
      totalWeight += weight;

      union(u, v); // Объединяем множества

      // Оптимизация: если уже добавили достаточное количество рёбер (V-1), выходим
      // В остовном дереве для V вершин всегда ровно V-1 рёбер
      if (edgeCount === vertices.length - 1) {
        break;
      }
    }
  }

  return {
    result,
    totalWeight,
  };
}

const vertices = ["A", "B", "C", "D", "E"];
const edges = [
  ["A", "B", 4],
  ["A", "C", 3],
  ["B", "C", 1],
  ["B", "D", 2],
  ["C", "D", 4],
  ["C", "E", 5],
  ["D", "E", 1],
];

console.log(kruskal(edges, vertices));
