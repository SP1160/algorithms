/**
 * Функция для нахождения минимального остовного дерева с помощью алгоритма Крускала
 * @param {Object} graph - Граф в формате объекта смежности
 * @returns {Object} - Объект с рёбрами MST и общим весом
 */
function kruskal(graph) {
  // ========== ШАГ 1: ПРЕОБРАЗОВАНИЕ ГРАФА В СПИСОК РЁБЕР ==========
  const edges = [];
  const vertices = [];

  // Собираем все вершины
  for (const vertex in graph) {
    if (vertices.indexOf(vertex) === -1) {
      vertices.push(vertex);
    }
  }

  // Преобразуем объект смежности в список рёбер
  for (const u in graph) {
    for (const v in graph[u]) {
      const weight = graph[u][v];
      // Добавляем ребро только если оно ещё не было добавлено в обратном направлении
      let alreadyExists = false;
      for (let i = 0; i < edges.length; i++) {
        const edge = edges[i];
        if ((edge[0] === u && edge[1] === v) || (edge[0] === v && edge[1] === u)) {
          alreadyExists = true;
          break;
        }
      }
      if (!alreadyExists) {
        edges.push([u, v, weight]);
      }
    }
  }

  // ========== ШАГ 2: СОРТИРОВКА РЁБЕР ==========
  // Сортируем все рёбра по возрастанию веса
  edges.sort((a, b) => a[2] - b[2]);

  // ========== ШАГ 3: ИНИЦИАЛИЗАЦИЯ DSU (Disjoint Set Union) ==========
  // Создаём структуру данных "Система непересекающихся множеств"
  const parent = {};

  // Инициализируем массив родителей
  // parent[vertex] = vertex означает, что вершина является корнем своего множества
  for (let i = 0; i < vertices.length; i++) {
    const vertex = vertices[i];
    parent[vertex] = vertex; // Изначально каждая вершина - своё собственное множество
  }

  // ========== ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ DSU ==========

  /**
   * Функция для нахождения корня множества с применением сжатия пути
   * @param {string} u - вершина, для которой ищем корень
   * @returns {string} - корень множества
   */
  const find = (u) => {
    // Поднимаемся по дереву до тех пор, пока не найдём корень
    // Корень - это вершина, которая является родителем самой себя (parent[u] === u)
    while (parent[u] !== u) {
      // PATH COMPRESSION (Сжатие пути) - ВАЖНАЯ ОПТИМИЗАЦИЯ!
      // Вместо простого u = parent[u], мы делаем parent[u] = parent[parent[u]]
      // Это делает дерево более плоским и ускоряет будущие поиски
      parent[u] = parent[parent[u]]; // "Перепрыгиваем" через одного предка
      u = parent[u]; // Переходим к новому родителю
    }

    return u;
  };

  /**
   * Функция для объединения двух множеств
   * @param {string} u - вершина из первого множества
   * @param {string} v - вершина из второго множества
   */
  const union = (u, v) => {
    // Находим корни множеств, к которым принадлежат вершины u и v
    const rootU = find(u);
    const rootV = find(v);

    // Проверяем, не находятся ли вершины уже в одном множестве
    if (rootU !== rootV) {
      // Простое объединение: делаем rootU родителем rootV
      // Это означает, что все элементы множества rootV теперь принадлежат множеству rootU
      parent[rootV] = rootU;
    }
  };

  // ========== ШАГ 4: ОСНОВНОЙ АЛГОРИТМ ==========
  const result = []; // Массив для хранения рёбер минимального остовного дерева

  // Проходим по всем рёбрам в порядке возрастания веса
  // Используем деструктуризацию: [u, v, weight] извлекает элементы из каждого ребра
  for (const [u, v, weight] of edges) {
    // Проверяем, создаст ли добавление этого ребра цикл
    // Если вершины u и v уже находятся в одном множестве (имеют одинаковый корень),
    // то между ними уже есть путь, и добавление ребра создаст цикл
    const rootU = find(u);
    const rootV = find(v);

    if (rootU !== rootV) {
      // Вершины в разных множествах - можно безопасно добавить ребро
      result.push([u, v, weight]); // Добавляем ребро в результат
      union(u, v); // Объединяем множества

      // Оптимизация: если уже добавили достаточное количество рёбер (V-1), выходим
      // В остовном дереве для V вершин всегда ровно V-1 рёбер
      if (result.length === vertices.length - 1) {
        break;
      }
    }
  }

  // Вычисляем общий вес MST
  const totalWeight = result.reduce((sum, element) => sum + element[2], 0);

  return {
    result,
    totalWeight,
  };
}

const graph = {
  a: { b: 2, c: 1 },
  b: { f: 7 },
  c: { d: 5, e: 2 },
  d: { f: 2 },
  e: { f: 1 },
  f: { g: 1 },
  g: {},
};

console.log(kruskal(graph));
