// /**
//  * Функция для нахождения минимального остовного дерева с помощью алгоритма Крускала
//  * @param {Array} edges - Список рёбер графа в формате [u, v, weight]
//  * @param {number} verticesCount - Количество вершин в графе
//  * @returns {Array} - Список рёбер минимального остовного дерева
//  */
// function kruskal(edges, verticesCount) {
//   // ========== ШАГ 1: СОРТИРОВКА РЁБЕР ==========
//   // Сортируем все рёбра по возрастанию веса
//   // a[2] и b[2] - это веса рёбер (третий элемент в массиве [u, v, weight])
//   // Если a[2] < b[2], то a должно идти раньше b в отсортированном массиве
//   edges.sort((a, b) => a[2] - b[2]);

//   // ========== ШАГ 2: ИНИЦИАЛИЗАЦИЯ DSU (Disjoint Set Union) ==========
//   // Создаём структуру данных "Система непересекающихся множеств"
//   const parent = [];

//   // Инициализируем массив родителей
//   // parent[i] = i означает, что вершина i является корнем своего множества
//   for (let i = 0; i < verticesCount; i++) {
//     parent[i] = i; // Изначально каждая вершина - своё собственное множество
//   }

//   // ========== ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ DSU ==========

//   /**
//    * Функция для нахождения корня множества с применением сжатия пути
//    * @param {number} u - вершина, для которой ищем корень
//    * @returns {number} - корень множества
//    */
//   const find = (u) => {
//     // Поднимаемся по дереву до тех пор, пока не найдём корень
//     // Корень - это вершина, которая является родителем самой себя (parent[u] === u)
//     while (parent[u] !== u) {
//       // PATH COMPRESSION (Сжатие пути) - ВАЖНАЯ ОПТИМИЗАЦИЯ!
//       // Вместо простого u = parent[u], мы делаем parent[u] = parent[parent[u]]
//       // Это делает дерево более плоским и ускоряет будущие поиски
//       parent[u] = parent[parent[u]]; // "Перепрыгиваем" через одного предка
//       u = parent[u]; // Переходим к новому родителю
//     }

//     return u;
//   };

//   /**
//    * Функция для объединения двух множеств
//    * @param {number} u - вершина из первого множества
//    * @param {number} v - вершина из второго множества
//    */
//   const union = (u, v) => {
//     // Находим корни множеств, к которым принадлежат вершины u и v
//     const rootU = find(u);
//     const rootV = find(v);

//     // Проверяем, не находятся ли вершины уже в одном множестве
//     if (rootU !== rootV) {
//       // Простое объединение: делаем rootU родителем rootV
//       // Это означает, что все элементы множества rootV теперь принадлежат множеству rootU
//       parent[rootV] = rootU;
//     }
//   };

//   // ========== ШАГ 3: ОСНОВНОЙ АЛГОРИТМ ==========
//   const result = []; // Массив для хранения рёбер минимального остовного дерева

//   // Проходим по всем рёбрам в порядке возрастания веса
//   // Используем деструктуризацию: [u, v, weight] извлекает элементы из каждого ребра
//   for (const [u, v, weight] of edges) {
//     // Проверяем, создаст ли добавление этого ребра цикл
//     // Если вершины u и v уже находятся в одном множестве (имеют одинаковый корень),
//     // то между ними уже есть путь, и добавление ребра создаст цикл
//     const rootU = find(u);
//     const rootV = find(v);

//     if (rootU !== rootV) {
//       // Вершины в разных множествах - можно безопасно добавить ребро
//       result.push([u, v, weight]); // Добавляем ребро в результат
//       union(u, v); // Объединяем множества

//       // Оптимизация: если уже добавили достаточное количество рёбер (V-1), выходим
//       // В остовном дереве для V вершин всегда ровно V-1 рёбер
//       if (result.length === verticesCount - 1) {
//         break;
//       }
//     }
//   }

//   // Вычисляем общий вес MST
//   const totalWeight = result.reduce((sum, element) => sum + element[2], 0);

//   return {
//     result,
//     totalWeight,
//   };
// }

// Определяем граф через список рёбер
// Каждое ребро представлено как [вершина1, вершина2, вес]
const edges = [
  [0, 1, 10], // Ребро между вершинами 0 и 1 с весом 10
  [0, 2, 6], // Ребро между вершинами 0 и 2 с весом 6
  [0, 3, 5], // Ребро между вершинами 0 и 3 с весом 5
  [1, 3, 15], // Ребро между вершинами 1 и 3 с весом 15
  [2, 3, 4], // Ребро между вершинами 2 и 3 с весом 4
];

const verticesCount = 4; // У нас 4 вершины: 0, 1, 2, 3

console.log(kruskal(edges, verticesCount));

function kruskal(edges, verticesCount) {
  edges.sort((a, b) => a[2] - b[2]);

  const parent = [];

  for (let i = 0; i < verticesCount; i++) {
    parent[i] = i;
  }

  function find(u) {
    while (parent[u] !== u) {
      parent[u] = parent[parent[u]];
      u = parent[u];
    }

    return u;
  }

  function union(u, v) {
    const rootU = find(u);
    const rootV = find(v);

    if (rootU !== rootV) {
      parent[rootV] = rootU;
    }
  }

  const result = [];

  for (let [u, v, weight] of edges) {
    const rootU = find(u);
    const rootV = find(v);

    if (rootU !== rootV) {
      result.push([u, v, weight]);
      union(u, v);
    }

    if (result.length === verticesCount - 1) {
      break;
    }
  }

  const totalWeight = result.reduce((sum, element) => sum + element[2], 0);

  return {
    result,
    totalWeight,
  };
}
