/**
 * Функция для нахождения минимального остовного дерева с помощью алгоритма Крускала
 * @param {Object} graph - Граф в формате объекта смежности
 * @returns {Object} - Объект с рёбрами MST и общим весом
 */
function kruskal(graph) {
  // ========== ШАГ 1: ПРЕОБРАЗОВАНИЕ ГРАФА В СПИСОК РЁБЕР ==========
  const edges = [];
  const vertices = [];

  // Собираем все вершины
  for (const vertex in graph) {
    if (vertices.indexOf(vertex) === -1) {
      vertices.push(vertex);
    }
  }

  // Преобразуем объект смежности в список рёбер
  for (const u in graph) {
    for (const v in graph[u]) {
      const weight = graph[u][v];
      // Добавляем ребро только если оно ещё не было добавлено в обратном направлении
      let alreadyExists = false;
      for (let i = 0; i < edges.length; i++) {
        const edge = edges[i];
        if ((edge[0] === u && edge[1] === v) || (edge[0] === v && edge[1] === u)) {
          alreadyExists = true;
          break;
        }
      }
      if (!alreadyExists) {
        edges.push([u, v, weight]);
      }
    }
  }

  // ========== ШАГ 2: СОРТИРОВКА РЁБЕР ==========
  // Сортируем все рёбра по возрастанию веса
  edges.sort((a, b) => a[2] - b[2]);

  // ========== ШАГ 3: ИНИЦИАЛИЗАЦИЯ DSU (Disjoint Set Union) ==========
  // Создаём структуру данных "Система непересекающихся множеств"
  const parent = {};

  // Инициализируем массив родителей
  // parent[vertex] = vertex означает, что вершина является корнем своего множества
  for (let i = 0; i < vertices.length; i++) {
    const vertex = vertices[i];
    parent[vertex] = vertex; // Изначально каждая вершина - своё собственное множество
  }

  // ========== ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ DSU ==========

  /**
   * Функция для нахождения корня множества с применением сжатия пути
   * @param {string} u - вершина, для которой ищем корень
   * @returns {string} - корень множества
   */
  const find = (u) => {
    // Поднимаемся по дереву до тех пор, пока не найдём корень
    // Корень - это вершина, которая является родителем самой себя (parent[u] === u)
    while (parent[u] !== u) {
      // PATH COMPRESSION (Сжатие пути) - ВАЖНАЯ ОПТИМИЗАЦИЯ!
      // Вместо простого u = parent[u], мы делаем parent[u] = parent[parent[u]]
      // Это делает дерево более плоским и ускоряет будущие поиски
      parent[u] = parent[parent[u]]; // "Перепрыгиваем" через одного предка
      u = parent[u]; // Переходим к новому родителю
    }

    return u;
  };

  /**
   * Функция для объединения двух множеств
   * @param {string} u - вершина из первого множества
   * @param {string} v - вершина из второго множества
   */
  const union = (u, v) => {
    // Находим корни множеств, к которым принадлежат вершины u и v
    const rootU = find(u);
    const rootV = find(v);

    // Проверяем, не находятся ли вершины уже в одном множестве
    if (rootU !== rootV) {
      // Простое объединение: делаем rootU родителем rootV
      // Это означает, что все элементы множества rootV теперь принадлежат множеству rootU
      parent[rootV] = rootU;
    }
  };

  // ========== ШАГ 4: ОСНОВНОЙ АЛГОРИТМ ==========
  const result = {}; // Объект для хранения результата в формате смежности
  let edgeCount = 0; // Счётчик добавленных рёбер
  let totalWeight = 0; // Общий вес MST

  // Инициализируем результирующий объект пустыми объектами для каждой вершины
  for (let i = 0; i < vertices.length; i++) {
    const vertex = vertices[i];
    result[vertex] = {};
  }

  // Проходим по всем рёбрам в порядке возрастания веса
  // Используем деструктуризацию: [u, v, weight] извлекает элементы из каждого ребра
  for (const [u, v, weight] of edges) {
    // Проверяем, создаст ли добавление этого ребра цикл
    // Если вершины u и v уже находятся в одном множестве (имеют одинаковый корень),
    // то между ними уже есть путь, и добавление ребра создаст цикл
    const rootU = find(u);
    const rootV = find(v);

    if (rootU !== rootV) {
      // Вершины в разных множествах - можно безопасно добавить ребро

      // Добавляем ребро в результирующий объект смежности в обоих направлениях
      result[u][v] = weight;
      result[v][u] = weight;

      // Увеличиваем счётчики
      edgeCount++;
      totalWeight += weight;

      union(u, v); // Объединяем множества

      // Оптимизация: если уже добавили достаточное количество рёбер (V-1), выходим
      // В остовном дереве для V вершин всегда ровно V-1 рёбер
      if (edgeCount === vertices.length - 1) {
        break;
      }
    }
  }

  return {
    result,
    totalWeight,
  };
}

const graph = {
  A: { B: 4, C: 3 },
  B: { A: 4, C: 1, D: 2 },
  C: { A: 3, B: 1, D: 4, E: 5 },
  D: { B: 2, C: 4, E: 1 },
  E: { C: 5, D: 1 },
};

console.log(kruskal(graph));
